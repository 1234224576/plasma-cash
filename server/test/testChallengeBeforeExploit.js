const ValidatorManagerContract = artifacts.require("ValidatorManagerContract");
const CryptoCards = artifacts.require("CryptoCards");
const RootChain = artifacts.require("RootChain");
import {increaseTimeTo, duration} from './helpers/increaseTime'
import assertRevert from './helpers/assertRevert.js';

const txlib = require('./UTXO.js')

contract("Plasma ERC721 - Invalid History Challenge / `challengeBefore` Exploit", async function(accounts) {

    const t1 = 3600 * 24 * 3; // 3 days later
    const t2 = 3600 * 24 * 5; // 5 days later

    // Alice registers and has 5 coins, and she deposits 3 of them.
    const ALICE_INITIAL_COINS = 5;
    const ALICE_DEPOSITED_COINS = 3;
    const COINS = [1, 2, 3];

    let cards;
    let plasma;
    let vmc;
    let events;
    let t0;

    let [authority, alice, bob, mallory, challenger] = accounts;

    beforeEach(async function() {
        vmc = await ValidatorManagerContract.new({from: authority});
        plasma = await RootChain.new(vmc.address, {from: authority});
        cards = await CryptoCards.new(plasma.address);
        await vmc.toggleToken(cards.address);
        cards.register({from: alice});
        assert.equal(await cards.balanceOf.call(alice), 5);

        let ret;
        for (let i = 0; i < ALICE_DEPOSITED_COINS; i ++) {
            await cards.depositToPlasma(COINS[i], {from: alice});
        }


        assert.equal((await cards.balanceOf.call(alice)).toNumber(), ALICE_INITIAL_COINS - ALICE_DEPOSITED_COINS);
        assert.equal((await cards.balanceOf.call(plasma.address)).toNumber(), ALICE_DEPOSITED_COINS);

        const depositEvent = plasma.Deposit({}, {fromBlock: 0, toBlock: 'latest'});
        events = await txlib.Promisify(cb => depositEvent.get(cb));

        // Check that events were emitted properly
        let coin;
        for (let i = 0; i < events.length; i++) {
            coin = events[i].args;
            assert.equal(coin.blockNumber.toNumber(), i+1);
            assert.equal(coin.denomination.toNumber(), 1);
            assert.equal(coin.from, alice);
        }

    });

    describe('Demonstrating challengeBeforeExploit', function() {
        it("Elliot makes a valid exit which gets challenged, however he responds with `respondChallengeBefore`", async function() {
            // let UTXO = {'slot': events[2]['args'].slot, 'block': events[2]['args'].blockNumber.toNumber()};
            // let alice_to_bob = txlib.createUTXO(UTXO.slot, UTXO.block, alice, bob);
            // let txs = [alice_to_bob.leaf];
            // let tree_1000 = await txlib.submitTransactions(authority, plasma, txs);
            // let aliceToBobBlock = 1000;

            // await plasma.submitBlock('0x0', {from: authority});

            // // Tx to Charlie from Bob referencing Bob's UTXO at block 1000
            // let bob_to_alice = txlib.createUTXO(UTXO.slot, aliceToBobBlock, bob, alice);
            // txs = [bob_to_alice.leaf];
            // let tree_3000 = await txlib.submitTransactions(authority, plasma, txs);
            // let bobToAliceBlock = 3000;

            // await plasma.submitBlock('0x0', {from: authority});

            // // Mallory creates false transaction to herself and colludes with
            // // the operator to include it in the chain
            // let alice_to_mallory = txlib.createUTXO(UTXO.slot, bobToAliceBlock, mallory, mallory);
            // txs = [alice_to_mallory.leaf]
            // let tree_5000 = await txlib.submitTransactions(authority, plasma, txs);
            // let fakeAliceToMalloryBlock = 5000;

            // // Mallory sends bad coin to Bob
            // let mallory_to_bob = txlib.createUTXO(UTXO.slot, fakeAliceToMalloryBlock, mallory, bob);
            // txs = [mallory_to_bob.leaf]
            // let tree_6000 = await txlib.submitTransactions(authority, plasma, txs);
            // let malloryToBobBlock = 6000;

            // // Bob sends bad coin back to Mallory
            // let bob_to_mallory = txlib.createUTXO(UTXO.slot, malloryToBobBlock, bob, mallory);
            // txs = [mallory_to_bob.leaf]
            // let tree_7000 = await txlib.submitTransactions(authority, plasma, txs);
            // let bobToMalloryBlock = 7000;

            // // Mallory tries to exit
            // let sig = bob_to_mallory.sig

            // let prev_tx_proof = tree_6000.createMerkleProof(UTXO.slot)
            // let exiting_tx_proof = tree_7000.createMerkleProof(UTXO.slot)

            // let prev_tx = mallory_to_bob.tx;
            // let exiting_tx = bob_to_mallory.tx;

            // plasma.startExit(
            //         UTXO.slot,
            //         prev_tx, exiting_tx,
            //         prev_tx_proof, exiting_tx_proof,
            //         sig,
            //         [malloryToBobBlock, bobToMalloryBlock],
            //         {'from': mallory, 'value': web3.toWei(0.1, 'ether')}
            // );
            // t0 = (await web3.eth.getBlock('latest')).timestamp;

            // // Alice challenges
            // sig = bob_to_alice.sig

            // prev_tx_proof = tree_1000.createMerkleProof(UTXO.slot)
            // exiting_tx_proof = tree_3000.createMerkleProof(UTXO.slot)

            // prev_tx = alice_to_bob.tx;
            // exiting_tx = bob_to_alice.tx;

            // await plasma.challengeBefore(
            //     UTXO.slot,
            //     prev_tx, exiting_tx,
            //     prev_tx_proof, exiting_tx_proof,
            //     sig,
            //     [aliceToBobBlock, bobToAliceBlock],
            //     {'from': alice, 'value': web3.toWei(0.1, 'ether')}
            // );

            // Mallory responds

            // await increaseTimeTo(t0 + t1 + t2);
            // Alice exits her coin
            // sig = bob_to_alice.sig

            // prev_tx_proof = tree_1000.createMerkleProof(UTXO.slot)
            // exiting_tx_proof = tree_3000.createMerkleProof(UTXO.slot)

            // prev_tx = alice_to_bob.tx;
            // exiting_tx = bob_to_alice.tx;

            // plasma.startExit(
            //         UTXO.slot,
            //         prev_tx, exiting_tx,
            //         prev_tx_proof, exiting_tx_proof,
            //         sig,
            //         [aliceToBobBlock, bobToAliceBlock],
            //         {'from': alice, 'value': web3.toWei(0.1, 'ether')}
            // );
            // aliceExitTime = (await web3.eth.getBlock('latest')).timestamp;

            // // Even though the coin still belongs to Alice, it is in the `EXITING` state so it shouldn't be possible for her to exit it
            // assertRevert(plasma.withdraw(UTXO.slot, {from: alice}));

            // // After the exit is matured and finalized, Alice can withdraw the coin.
            // await increaseTimeTo(aliceExitTime + t1 + t2);
            // await plasma.finalizeExits({from: authority});
            // assertRevert(plasma.withdraw(UTXO.slot, {from: mallory}));
            // assertRevert(plasma.withdraw(UTXO.slot, {from: bob}));
            // await plasma.withdraw(UTXO.slot, {from: alice});
            // assert.equal(await cards.balanceOf.call(alice), 3);
            // assert.equal(await cards.balanceOf.call(bob), 0);
            // assert.equal(await cards.balanceOf.call(mallory), 0);
            // assert.equal(await cards.balanceOf.call(plasma.address), 2);

            // // Alice is also able to withdraw his deposit bond of 0.1 ether
            // await txlib.withdrawBonds(plasma, alice, 0.1);
        });
    });
});
