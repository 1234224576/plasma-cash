const CryptoCards = artifacts.require("CryptoCards");
const RootChain = artifacts.require("RootChain");
import {increaseTimeTo, duration} from './helpers/increaseTime'
import assertRevert from './helpers/assertRevert.js';

const txlib = require('./UTXO.js')

contract("Plasma ERC721 - Double Spend Challenge / `challengeBetween`", async function(accounts) {

    const t1 = 3600 * 24 * 3; // 3 days later
    const t2 = 3600 * 24 * 5; // 5 days later

    // Alice registers and has 5 coins, and she deposits 3 of them.
    const ALICE_INITIAL_COINS = 5;
    const ALICE_DEPOSITED_COINS = 3;
    const COINS = [1, 2, 3];

    let cards;
    let plasma;
    let events;
    let t0;

    let [authority, alice, bob, charlie, dylan, elliot, random_guy, random_guy2, challenger] = accounts;

    beforeEach(async function() {
        plasma = await RootChain.new({from: authority});
        cards = await CryptoCards.new(plasma.address);
        plasma.setERC721(cards.address);
        cards.register({from: alice});
        assert.equal(await cards.balanceOf.call(alice), 5);

        let ret;
        for (let i = 0; i < ALICE_DEPOSITED_COINS; i++) {
            await cards.depositToPlasma(COINS[i], {from: alice});
        }


        assert.equal((await cards.balanceOf.call(alice)).toNumber(), ALICE_INITIAL_COINS - ALICE_DEPOSITED_COINS);
        assert.equal((await cards.balanceOf.call(plasma.address)).toNumber(), ALICE_DEPOSITED_COINS);

        const depositEvent = plasma.Deposit({}, {fromBlock: 0, toBlock: 'latest'});
        events = await txlib.Promisify(cb => depositEvent.get(cb));

        // Check that events were emitted properly
        let coin;
        for (let i = 0; i < events.length; i++) {
            coin = events[i].args;
            assert.equal(coin.blockNumber.toNumber(), i+1);
            assert.equal(coin.denomination.toNumber(), 1);
            assert.equal(coin.from, alice);
        }

    });

    it("Bob gives a coin to Dylan. Dylan exits, gets challenged by an invalid tx by Charlie who colluded with the Operator", async function() {
        let UTXO = {'slot': events[2]['args'].slot, 'block': events[2]['args'].blockNumber.toNumber()};

        let alice_to_bob = txlib.createUTXO(UTXO.slot, UTXO.block, alice, bob);
        let txs = [ alice_to_bob.leaf ];
        let tree_bob = await txlib.submitTransactions(authority, plasma, txs);

        // Invalid transaction-block which is not signed by Bob, however will be used to challenge
        let bob_to_charlie = txlib.createUTXO(UTXO.slot, 1000, challenger, charlie);
        txs = [ bob_to_charlie.leaf ];
        let tree_charlie = await txlib.submitTransactions(authority, plasma, txs);

        let bob_to_dylan = txlib.createUTXO(UTXO.slot, 1000, bob, dylan);
        txs = [ bob_to_dylan.leaf ];
        let tree_dylan = await txlib.submitTransactions(authority, plasma, txs);

        let exiting_tx = bob_to_dylan.tx;
        let sig = bob_to_dylan.sig;
        let prev_tx = alice_to_bob.tx;
        let prev_tx_proof = tree_bob.createMerkleProof(UTXO.slot)
        let exiting_tx_proof = tree_dylan.createMerkleProof(UTXO.slot)

        await plasma.startExit(
            UTXO.slot,
            prev_tx, exiting_tx,
            prev_tx_proof, exiting_tx_proof,
            sig,
            1000, 3000,
            {'from': dylan, 'value': web3.toWei(0.1, 'ether')}
        );

        let challengeTx = bob_to_charlie.tx;
        let sig = bob_to_charlie.sig;
        let proof = tree_charlie.createMerkleProof(UTXO.slot);
        let block_number = 2000; // Charlie's transaction which is the valid one was included at block 2000

        await plasma.challengeBetween(
            UTXO.slot, block_number, challengeTx, proof, sig
            {'from': challenger}
        );

         t0 = (await web3.eth.getBlock('latest')).timestamp;
        await increaseTimeTo(t0 + t1 + t2);
        await plasma.finalizeExits({from: random_guy2});
        await txlib.withdrawBonds(plasma, challenger, 0.1);
    });

});
